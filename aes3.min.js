"use strict";function AES3(){let aes={encrypt:async(message,password,passwordBits,iterations)=>{let pass,rounds=iterations||5e5,iterationsHash=btoa(rounds.toString()).replace(/\=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),msg=(new TextEncoder).encode(message);password&&(pass=await crypto.subtle.importKey("raw",(new TextEncoder).encode(password),{name:"PBKDF2"},!1,["deriveBits"])),passwordBits&&(pass=await crypto.subtle.importKey("raw",new Uint8Array(passwordBits),{name:"PBKDF2"},!1,["deriveBits"]));let salt=crypto.getRandomValues(new Uint8Array(32)),saltHash=btoa(Array.from(new Uint8Array(salt)).map(val=>String.fromCharCode(val)).join("")).replace(/\=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),iv=crypto.getRandomValues(new Uint8Array(12)),ivHash=btoa(Array.from(new Uint8Array(iv)).map(val=>String.fromCharCode(val)).join("")).replace(/\=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),bits=await crypto.subtle.deriveBits({name:"PBKDF2",salt:salt,iterations:rounds,hash:{name:"SHA-256"}},pass,512),aesBits=bits.slice(32,64),aesKey=await crypto.subtle.importKey("raw",aesBits,{name:"AES-GCM"},!1,["encrypt"]),hmacBits=bits.slice(0,32),hmacKey=await crypto.subtle.importKey("raw",hmacBits,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),enc=await crypto.subtle.encrypt({name:"AES-GCM",iv:iv},aesKey,msg),encrypted=iterationsHash+"."+saltHash+"."+ivHash+"."+btoa(Array.from(new Uint8Array(enc)).map(val=>String.fromCharCode(val)).join("")).replace(/\=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),sigData=(new TextEncoder).encode(encrypted),signature=await crypto.subtle.sign({name:"HMAC"},hmacKey,sigData);return encrypted+"."+btoa(Array.from(new Uint8Array(signature)).map(val=>String.fromCharCode(val)).join("")).replace(/\=/g,"").replace(/\+/g,"-").replace(/\//g,"_")},decrypt:async(encrypted,password,passwordBits)=>{let pass,parts=encrypted.split("."),rounds=parseInt(atob(parts[0])),salt=new Uint8Array(atob(parts[1].replace(/-/g,"+").replace(/_/g,"/")).split("").map(val=>val.charCodeAt(0))),iv=new Uint8Array(atob(parts[2].replace(/-/g,"+").replace(/_/g,"/")).split("").map(val=>val.charCodeAt(0))),enc=new Uint8Array(atob(parts[3].replace(/-/g,"+").replace(/_/g,"/")).split("").map(val=>val.charCodeAt(0))),sig=new Uint8Array(atob(parts[4].replace(/-/g,"+").replace(/_/g,"/")).split("").map(val=>val.charCodeAt(0)));password&&(pass=await crypto.subtle.importKey("raw",(new TextEncoder).encode(password),{name:"PBKDF2"},!1,["deriveBits"])),passwordBits&&(pass=await crypto.subtle.importKey("raw",new Uint8Array(passwordBits),{name:"PBKDF2"},!1,["deriveBits"]));let bits=await crypto.subtle.deriveBits({name:"PBKDF2",salt:salt,iterations:rounds,hash:{name:"SHA-256"}},pass,512),aesBits=bits.slice(32,64),aesKey=await crypto.subtle.importKey("raw",aesBits,{name:"AES-GCM"},!1,["decrypt"]),hmacBits=bits.slice(0,32),hmacKey=await crypto.subtle.importKey("raw",hmacBits,{name:"HMAC",hash:{name:"SHA-256"}},!1,["verify"]),sigData=(new TextEncoder).encode(encrypted.split(".").slice(0,4).join("."));if(!await crypto.subtle.verify({name:"HMAC"},hmacKey,sig,sigData))return Promise.reject({error:"Password or signature does not match."});let dec=await crypto.subtle.decrypt({name:"AES-GCM",iv:iv},aesKey,enc);return(new TextDecoder).decode(dec)}};return aes}